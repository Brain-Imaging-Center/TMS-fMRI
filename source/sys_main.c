/** @file sys_main.c 
*   @brief Application main file
*   @date 9.Sep.2014
*   @version 04.01.00
*
*   This file contains an empty main function,
*   which can be used for the application.
*/

/* (c) Texas Instruments 2009-2014, All rights reserved. */

/* USER CODE BEGIN (0) */
/* USER CODE END */

/* Include Files */

#include "sys_common.h"

/* USER CODE BEGIN (1) */
#include "rti.h"
#include "het.h"
#include "gio.h"
#include "TMS_scanner_synch.h"
#include "stdio.h"     // For file reading functions.
#include "stdlib.h"    // For the exit() function.

unsigned int irq_count;
unsigned int train_count;
unsigned int trig_in_train_count;
unsigned int TMS_trig_in_progress;

TMS_struct TMS[200];



/* USER CODE END */

/** @fn void main(void)
*   @brief Application main function
*   @note This function is empty by default.
*
*   This function is called after startup.
*   The user can use this function to implement the application.
*/

/* USER CODE BEGIN (2) */
/* USER CODE END */

void main(void)
{
/* USER CODE BEGIN (3) */

	// Some declarations
	unsigned int vol_num, num_trigs, trig_time, m, n;
	FILE *TMS_data_file;

	// Initialize some variables used in ISRs and initialize hardware state.
	irq_count = 0;
	train_count = 0;
	trig_in_train_count = 0;
	TMS_trig_in_progress = 0;

	// Read data from a file containing all the TMS delivery information.
    TMS_data_file = fopen("C:\\Users\\BIC\\workspace_v6_0\\Blinky\\TMS_trig_files\\TMS_trig_data","r");
    if(TMS_data_file == NULL){
      printf("\n Can't open TMS_trig_data \n");
      fflush(stdout);
      exit (1);
    }

    m = 0;
    while(fscanf(TMS_data_file, "%u %u", &vol_num, &num_trigs) != EOF){
      // Read the volume number for trigger train and the number of triggers in the train.
      TMS[m].trig_image_vol = vol_num;
      TMS[m].num_trigs_in_train = num_trigs;
      for(n=0; n<num_trigs; n++){
        fscanf(TMS_data_file, "%u", &trig_time);
        TMS[m].trig_time[n] = trig_time - TRIG_TO_TMS_PULSE_DELAY;  // Account for TMS unit delays. See TMS_scanner_synch.h
                                                                    // for more detail about this delay.

      }
      m = m + 1;
    }
    fclose(TMS_data_file);
    printf ("Ready to send triggers to TMS unit. \n");
    fflush(stdout);

	// Initialize rti, gio and associated hardware interrupts.
	rtiInit();
	gioInit();
	gioSetDirection(hetPORT1, 0xFFFFFFFF);

	/* The following line sets pins A0 and A2 of GIO PORTA to output and pin A7 of
    GIO PORTA to input. A0 is used for output to the TMS unit. A7 is used for input
	from the MRI TTL pulse. A2 controls an LED, used for testing, on the board. */
	gioSetDirection(gioPORTA, 0x00000005);

	rtiEnableNotification(rtiNOTIFICATION_COMPARE0);
	_enable_interrupt_();
	_enable_IRQ();

	// Start the rti counter.
	rtiStartCounter(rtiCOUNTER_BLOCK0);  // !!!!! Wont need this since I will be starting the counter in the gioNotification ISR
	                                     // and since the counter must be stopped before the reset done in the gioNotification ISR.

	// Initialize hardware state.
	gioSetPort(hetPORT1, 0x00000000); // Set output to D11 LED initially to low.

	// Initialize prescaler so that time units will be microseconds. Using 99 sets
	// the base frequency to 100th of the 100MHz operating frequency. See above
	// lines which set pulse_length and scanner_irq_to_gio_out_delay times.
	rtiREG1->CNT[0U].CPUCx = 99;
	//printf ("RTICPUC0: %d \n", rtiREG1->CNT[0U].CPUCx);

	while(1);

/* USER CODE END */
}

/* USER CODE BEGIN (4) */
/* The rtiNotification() routine is the ISR (interrupt service routine) for the hardware interrupt generated by
 * the microcontroller's RTI clock. The RTI clock hardware interrupt occurs when the associated counter reaches
 * the value assigned to COMPx. COMPx is first set within the gioNotification ISR (see the file notification.c)
 * and this sets the time (relative to a choosen scanner TTL) at which the first RTI clock hardware interrupt
 * will occur following a scanner TTL. Within rtiNotification the leading and trailing edges of the trigger
 * (3.3 V and 10 us on gioPORTA pin A0) to TMS unit are set. This requires a resetting of the RTI clock
 * counter depending upon the values of start_trig and end_trig. The length of the trigger to the TMS unit
 * is given by the pulse_length variable which is set in the TMS_scanner_synch.h header file.
 *
 * You must recompile this code each time you change the TMS_trigger_data file. After recompiling this code it
 * is then flashed (loaded) to the microcontroller. Apparently the microcontroller is good for 100K such flashes.
 * So after much use the code could fail to flash to the microcontroller. Simply replace the microcontroller to
 * fix this problem.*/

void rtiNotification(uint32 notification)
{

    // Service the hardware interrupt according to whether the trigger (3.3V and 10 us) to the TMS has been initiated already or not.
	if(TMS_trig_in_progress == 0){

	   // Set the next timer hardware interupt to occur pulse_length (10 us) later (see case 2).
	   rtiREG1->CMP[0U].COMPx = rtiREG1->CNT[0U].CAFRCx + PULSE_LENGTH + TMS[train_count].trig_time[trig_in_train_count];

	   // Set 08 pin of NHET port to high. Turns D11 LED on. This is for trouble shooting only.
	   gioSetPort(hetPORT1, 0x00000100);

	   // Sets A0 pin of GIO PORTA to high. This is the pin for the trigger to the TMS unit.
	   gioSetPort(gioPORTA, 0x00000001);

	   // Set control flags
	   TMS_trig_in_progress = 1;

	} else {

	   // Set pin 08 of the NHET port to low to turn the Hercules board D11 LED off. For trouble shooting only.
	   gioSetPort(hetPORT1, 0x00000000);

	   // Set pin A0 of the GIO PORTA to low. This is the pin for the trigger to the TMS unit.
	   gioSetPort(gioPORTA, 0x00000000);

	   // Set the next timer hardware interupt to occur beginning the next trigger pulse to the TMS unit.
	   trig_in_train_count = trig_in_train_count + 1;
	   if(trig_in_train_count < TMS[train_count].num_trigs_in_train){
	     rtiREG1->CMP[0U].COMPx = rtiREG1->CNT[0U].CAFRCx + TMS[train_count].trig_time[trig_in_train_count];
	   } else {
		   train_count = train_count + 1;   // This counter is used as an index to step through the arrays
		   	                                // irq_to_trig_delay_array and trig_array.
		   trig_in_train_count = 0;
	   }

	   // Set control flag.
	   TMS_trig_in_progress = 0;
	}
}
/* USER CODE END */
